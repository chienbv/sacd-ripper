#summary The ScarletBook is Philips and Sony's 1999 specification document for Super Audio Compact Disc ( SACD ).

= Introduction =

The ScarletBook is Philips and Sony's 1999 specification document for Super Audio Compact Disc ( SACD ), a high-resolution audio format that features multi-channel sound. SACD discs can contain two different versions of the same material.

= Pit Signal Processing =

SACD includes various copy protection measures of which the most prominent is Pit Signal Processing (PSP), a physical watermarking feature that contains a digital watermark modulated in the width of pits on the disc (data are stored in the pit length). The optical pickup must contain special circuitry to read the PSP watermark, which is then compared to information on the disc to make sure it is legitimate. Because the majority of DVD players and all DVD-ROM drives use an optical pickup that lacks this specialized watermark detection circuitry, although they can read the data on the SACD layer, they cannot decode the audio of a protected SACD disc. With one exception: The first two generations of Sony's PlayStation 3 (PS3) game console are capable of reading SACD ScarletBook and bypass the copy protection. 

= Specification =

A ScarletBook disk always contains a Master Table of Contents (TOC). This Master TOC is stored several times to insure there is a backup in case of disc corruption. The Master (TOC) stores all information related to the disc, this includes position & size to two or multi channel TOCs, album title, album artist and genre data. 

Track data is stored in a continuous stream and consists of 1 or 2 areas. The following combinations of areas on a disc are allowed:
  * 2-channel area
  * 5-channel area
  * 6-channel area
  * 2-channel and 5-channel area
  * 2-channel and 6-channel area

The Two or Multi Channel TOC referred by the Master TOC, include track count, disc and track titles, track artist and ISRC codes, genre data and (optional) Super Audio CD text information which can be displayed during playback. 

There is lot's of speculation about an UDF filesystem for SACDs, but UDF is not part of the specification as most discs don't have it.

=== ScarletBook SACD Example ===

{{{

//                  Start LSN    Size     Comment
//                  -----------  -------  ---------------------------------------------
// File System      0            510      Only some SACD's have UDF data, so ignore..
// Master TOC-1     510          10
// Master TOC-2     520          10
// Master TOC-3     530          10
// 2 Channel
//   Area TOC-1     -            -        position & size is stored in Master TOC
//   Track Area     -            -        position, size is stored in Channel Area TOC
//   Area TOC-2     -            -        position & size is stored in Master TOC
// Multi Channel
//   Area TOC-1     -            -        position & size is stored in Master TOC
//   Track Area     -            -        position, size is stored in Channel Area TOC
//   Area TOC-2     -            -        position & size is stored in Master TOC
//
//

}}}

Numbers are stored in big endian format.

=== Block Addressing (LSN) ===

A ScarletBook disk is broken up into a number of 2048-byte blocks which we call frames. The way ScarletBook addresses a block is to use its LSN or "logical sector number." ScarletBook numbers the blocks from 0 on.

== Master TOC ==

{{{

#define START_OF_FILE_SYSTEM_AREA   0
#define START_OF_MASTER_TOC         510
#define SACD_RAW_FRAME_SIZE         2048
#define MAX_AREA_TOC_SIZE_LSN       96
#define SAMPLES_PER_FRAME           588

#define DST_ENCODED                 0
#define DSD_3_IN_14_ENCODED         2
#define DSD_3_IN_16_ENCODED         3

enum
{
    CHAR_SET_UNKNOWN          = 0
  , CHAR_SET_ISO646           = 1
  , CHAR_SET_ISO8859_1        = 2
  , CHAR_SET_RIS506           = 3
  , CHAR_SET_KSC5601          = 4
  , CHAR_SET_GB2312           = 5
  , CHAR_SET_BIG5             = 6
  , CHAR_SET_ISO8859_1_ESC    = 7

} character_set_t;

static const char *genre[] =
{
    "Not used"
  , "Not defined"
  , "Adult Contemporary"
  , "Alternative Rock"
  , "Children's Music"
  , "Classical"
  , "Contemporary Christian"
  , "Country"
  , "Dance"
  , "Easy Listening"
  , "Erotic"
  , "Folk"
  , "Gospel"
  , "Hip Hop"
  , "Jazz"
  , "Latin"
  , "Musical"
  , "New Age"
  , "Opera"
  , "Operetta"
  , "Pop Music"
  , "RAP"
  , "Reggae"
  , "Rock Music"
  , "Rhythm & Blues"
  , "Sound Effects"
  , "Sound Track"
  , "Spoken Word"
  , "World Music"
  , "Blues"
  , 0
}

enum
{
    GENRE_NOT_USED                      = 0
  , GENRE_NOT_DEFINED                   = 1
  , GENRE_ADULT_CONTEMPORARY            = 2
  , GENRE_ALTERNATIVE_ROCK              = 3
  , GENRE_CHILDRENS_MUSIC               = 4
  , GENRE_CLASSICAL                     = 5
  , GENRE_CONTEMPORARY_CHRISTIAN        = 6
  , GENRE_COUNTRY                       = 7
  , GENRE_DANCE                         = 8
  , GENRE_EASY_LISTENING                = 9
  , GENRE_EROTIC                        = 10
  , GENRE_FOLK                          = 11
  , GENRE_GOSPEL                        = 12
  , GENRE_HIP_HOP                       = 13
  , GENRE_JAZZ                          = 14
  , GENRE_LATIN                         = 15
  , GENRE_MUSICAL                       = 16
  , GENRE_NEW_AGE                       = 17
  , GENRE_OPERA                         = 18
  , GENRE_OPERETTA                      = 19
  , GENRE_POP_MUSIC                     = 20
  , GENRE_RAP                           = 21
  , GENRE_REGGAE                        = 22
  , GENRE_ROCK_MUSIC                    = 23
  , GENRE_RHYTHM_AND_BLUES              = 24
  , GENRE_SOUND_EFFECTS                 = 25
  , GENRE_SOUND_TRACK                   = 26
  , GENRE_SPOKEN_WORD                   = 27
  , GENRE_WORLD_MUSIC                   = 28
  , GENRE_BLUES                         = 29

} genre_t;

enum
{
    CATEGORY_NOT_USED                   = 0
  , CATEGORY_GENERAL                    = 1
  , CATEGORY_JAPANESE                   = 2

} category_t;

enum
{
    TRACK_TYPE_TITLE                    = 0x01
  , TRACK_TYPE_PERFORMER                = 0x02
  , TRACK_TYPE_SONGWRITER               = 0x03
  , TRACK_TYPE_COMPOSER                 = 0x04
  , TRACK_TYPE_ARRANGER                 = 0x05
  , TRACK_TYPE_MESSAGE                  = 0x06
  , TRACK_TYPE_EXTRA_MESSAGE            = 0x07

  , TRACK_TYPE_TITLE_PHONETIC           = 0x81
  , TRACK_TYPE_PERFORMER_PHONETIC       = 0x82
  , TRACK_TYPE_SONGWRITER_PHONETIC      = 0x83
  , TRACK_TYPE_COMPOSER_PHONETIC        = 0x84
  , TRACK_TYPE_ARRANGER_PHONETIC        = 0x85
  , TRACK_TYPE_MESSAGE_PHONETIC         = 0x86
  , TRACK_TYPE_EXTRA_MESSAGE_PHONETIC   = 0x87

} track_type_t;

}}}

=== Master Area TOC ===

{{{
typedef struct
{
  uint8_t        category;                  // category_t
  uint16_t       padding;
  uint8_t        genre;                     // genre_t
} genre_table_t;

typedef struct
{
  char           language_code[2];          // ISO639-2 Language code
  uint8_t        character_set;             // char_set_t
  uint8_t        padding;
} lang_table_t;

typedef struct
{
  uint64_t       id;                        // SACDMTOC
  uint16_t       disc_version;              // 1.20 / 0x0114
  uint8_t        unknown_01[6];
  uint16_t       album_set_size;
  uint16_t       album_sequence_number;
  uint8_t        unknown_02[4];
  char           album_catalog_number[16];  // 0x00 when empty, else padded with spaces for short strings
  genre_table_t  album_genre[4];
  uint8_t        unknown_03[8];
  uint32_t       ch2_toc1_area_start;
  uint32_t       ch2_toc2_area_start;
  uint32_t       chm_toc1_area_start;
  uint32_t       chm_toc2_area_start;
  uint8_t        disc_type;                 // 0x80 hybrid, 0x00 for single, 0x?? for dual?
  uint8_t        unknown_04[3];             // padding?
  uint16_t       ch2_toc_area_size;
  uint16_t       chm_toc_area_size;
  char           disc_catalog_number[16];   // 0x00 when empty, else padded with spaces for short strings
  genre_table_t  disc_genre[4];
  uint16_t       disc_date_year;
  uint8_t        disc_date_month;
  uint8_t        disc_date_day;
  uint8_t        unknown_05[4];             // time?
  uint8_t        text_channel_count;
  uint8_t        unknown_06[7];
  lang_table_t   languages[8];
} master_toc_t;

typedef struct
{
  uint64_t       id;                        // SACDText
  uint64_t       unknown_01;
  uint16_t       album_title_position;
  uint16_t       album_title_phonetic_position;
  uint16_t       album_artist_position;
  uint16_t       album_artist_phonetic_position;
  uint16_t       album_publisher_position;
  uint16_t       album_publisher_phonetic_position;
  uint16_t       album_copyright_position;
  uint16_t       album_copyright_phonetic_position;
  uint16_t       disc_title_position;
  uint16_t       disc_title_phonetic_position;
  uint16_t       disc_artist_position;
  uint16_t       disc_artist_phonetic_position;
  uint16_t       disc_publisher_position;
  uint16_t       disc_publisher_phonetic_position;
  uint16_t       disc_copyright_position;
  uint16_t       disc_copyright_phonetic_position;
  uint8_t        data[2000];
} master_text_t;

typedef struct
{
  uint64_t       id;                        // SACD_Man
  uint8_t        data[2040];
} master_man_t;

}}}

== Two or Multi Channel TOC ==

{{{

typedef struct
{
  uint64_t       id;                        // TWOCHTOC or MULCHTOC
  uint16_t       version;                   // 1.20, 0x0114
  uint16_t       size;                      // ex. 40 (total size of TOC)
  uint8_t        unknown_01[20];
  uint8_t        loudspeaker_config;
  uint8_t        channel_count;
  uint8_t        unknown_02[30];
  uint32_t       unknown_03;
  uint16_t       track_count;
  uint16_t       unknown_04;
  uint32_t       track_position;
  uint32_t       track_length;
  uint8_t        text_channel_count;
  uint8_t        unknown_06[7];
  lang_table_t   languages[10];
  uint8_t        unknown_05[16];
  uint16_t       area_description_offset;
  uint16_t       copyright_offset;
  uint16_t       area_description_phonetic_offset;
  uint16_t       copyright_phonetic_offset;
  uint8_t        data[1896];
} channel_toc_t;

typedef struct
{
  uint8_t        track_text_count;
  uint16_t       unknown_01;
  uint8_t        track_type;
  uint8_t        unknown_02;
  char           track_text[];
} track_text_t;

typedef struct
{
  uint64_t       id;                        // SACDText
  uint16_t       track_text_position[255];
  uint8_t        data[];
} channel_text_t;

typedef struct
{
  char           country_code[2];
  char           owner_code[3];
  char           recording_year[2];
  char           designation_code[5];
} isrc_t;

typedef struct
{
  uint64_t       id;                        // SACD_IGL
  isrc_t         isrc[255];
} channel_isrc_t;

typedef struct
{
  uint64_t       id;                        // SACD_ACC
  uint8_t        data[0xfff8];
} channel_index_t;

typedef struct
{
  uint64_t       id;                        // SACDTRL1
  uint32_t       track_start_lsn[255];
  uint32_t       track_stop_lsn[255];
} channel_tracklist_1_t;

typedef struct
{
  uint64_t       id;                        // SACDTRL2
  uint32_t       track_start_time[255];			// time in ms
  uint32_t       track_stop_time[255];
} channel_tracklist_2_t;

}}}